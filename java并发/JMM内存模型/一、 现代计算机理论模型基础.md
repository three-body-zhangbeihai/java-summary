# 一、 现代计算机理论模型基础

### 1.计算机五大核心组成

1. 控制器(Control)：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解 释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访 问等。

2. 运算器(Datapath)：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进 行加工处理。

3. 存储器(Memory)：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需 要时提供这些信息。

4. 输入(Input system)：输入设备是计算机的重要组成部分，输入设备与输出设备合你为 外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采 集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘 机、光盘机等。

5. 输出(Output system)：输出设备与输入设备同样是计算机的重要组成部分，它把外算 机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。微机 常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。

   

   ![img](https://upload-images.jianshu.io/upload_images/18607686-65d22c706ea47414.png?imageMogr2/auto-orient/strip|imageView2/2/w/935/format/webp)

   冯诺依曼计算机模型

### 2.现代计算机硬件结构原理图



![img](https://upload-images.jianshu.io/upload_images/18607686-78f9da4f6b354e06.png?imageMogr2/auto-orient/strip|imageView2/2/w/1155/format/webp)

现代计算机硬件结构

## 3.CPU内部结构划分

1. 控制单元: 是整个CPU的指挥控制中心，由指令寄存器IR（Instruction Register）、指令 译码器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等组成， 对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指 令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制 器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括：节拍 脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。

2. 运算单元: 是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运算） 和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控制单元 的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的， 所以它是执行部件。

3. 存储单元：包括 CPU 片内缓存Cache和寄存器组，是 CPU 中暂时存放数据的地方，里面 保存着那些等待处理的数据，或已经处理过的数据，CPU 访问寄存器所用的时间要比访问内 存的时间短。 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存器之间 的数据传送非常快。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作 速度。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应 的数据；而通用寄存器用途广泛并可由程序员规定其用途。

   

   ![img](https://upload-images.jianshu.io/upload_images/18607686-09139427b2434810.png?imageMogr2/auto-orient/strip|imageView2/2/w/920/format/webp)

   CPU结构

## 4.CPU多核缓存架构

1. 多CPU 一个现代计算机通常由两个或者多个CPU，如果要运行多个程序（进程）的话，假如只有 一个CPU的话，就意味着要经常进行进程上下文切换，因为单CPU即便是多核的，也只是多个 处理器核心，其他设备都是共用的，所以 多个进程就必然要经常进行进程上下文切换，这个代 价是很高的。

2. CPU多核 一个现代CPU除了处理器核心之外还包括寄存器、L1L2L3缓存这些存储设备、浮点运算 单元、整数运算单元等一些辅助运算设备以及内部总线等。一个多核的CPU也就是一个CPU上 有多个处理器核心，这样有什么好处呢？比如说现在我们要在一台计算机上跑一个多线程的程 序，因为是一个进程里的线程，所以需要一些共享一些存储变量，如果这台计算机都是单核单 线程CPU的话，就意味着这个程序的不同线程需要经常在CPU之间的外部总线上通信，同时还 要处理不同CPU之间不同缓存导致数据不一致的问题，所以在这种场景下多核单CPU的架构就 能发挥很大的优势，通信都在内部总线，共用同一个缓存。

3. CPU寄存器 每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的 速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。

4. CPU缓存 即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于 CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着

   

   ![img](https://upload-images.jianshu.io/upload_images/18607686-e570cc837cdd77d3.png?imageMogr2/auto-orient/strip|imageView2/2/w/683/format/webp)

   CPU多核缓存架构

# 线程

## 1.什么是线程？

进程是系统分配资源的基本单位，线程是调度CPU的基本单位，一个进程至少包含一个执行线程，线程寄生在进程当中。每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）

## 2.线程分类

- 用户级线程(User-Level Thread)
  用户线程简称ULT，指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。另外，用户线程是由应用进程利用线程库创建和管理，不依赖于操作系统核心。不需要用户态/核心态切换，速度快。操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。
- 内核线线程(Kernel-Level Thread)
  内核线程简称KLT，线程的所有管理操作都是由操作系统内核完成的。内核保存线程的状态和上下文信息，当一个线程执行了引起阻塞的系统调用时，内核可以调度该进程的其他线程执行。在多处理器系统上，内核可以分派属于同一进程的多个线程在多个处理器上运行，提高进程执行的并行度。由于需要内核完成线程的创建、调度和管理，所以和用户级线程相比这些操作要慢得多，但是仍然比进程的创建和管理操作要快。大多数市场上的操作系统，如Windows，Linux等都支持内核级线程。

**用户空间划分**

- 内核空间

- 用户空间

  

  ![img](https://upload-images.jianshu.io/upload_images/18607686-940242bdfe997f79.png?imageMogr2/auto-orient/strip|imageView2/2/w/1137/format/webp)

  image.png

## 3. Java线程与系统内核线程关系



![img](https://upload-images.jianshu.io/upload_images/18607686-01a5632aa5d59f2d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image.png

## 4.Java线程的生命周期

1. 新建（New）

2. 就绪（Ready）

3. 运行（Running）

4. 等待 (Waiting)

5. 超时等待(Timed_Waiting)

6. 阻塞（Blocked)

7. 终止（Terminated）

   

   ![img](https://upload-images.jianshu.io/upload_images/18607686-c87caef8466e3e29.png?imageMogr2/auto-orient/strip|imageView2/2/w/983/format/webp)

   Java线程的生命周期

# 并发

## 1. 为什么用到并发

并发编程的本质其实就是利用多线程技术，在现代多核的CPU的背景下，催生了并发编程 的趋势，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。除此之 外，面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业 务拆分 。 即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现 这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切 换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。 并发不等于并行：并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进 行”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行， 只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多 个CPU的系统中。

## 2.并发产生的问题

#### 1. 频繁的上下文切换

任务从保存到再加载的过程就是一次上下文切换。



![img](https://upload-images.jianshu.io/upload_images/18607686-22e28b9a2af0638f.png?imageMogr2/auto-orient/strip|imageView2/2/w/953/format/webp)

线程上下文切换过程

#### 2. 缓存一致性

在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存 （MainMemory）。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是 也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一 块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步 回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都 遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、 MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等

**MESI(Modified Exclusive Shared Or Invalid)协议**

| 状态                     | 描述                                                         | 监听任务                                                     |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| M 修改 (Modified)        | 该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 | 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。 |
| E 独享、互斥 (Exclusive) | 该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。 | 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。 |
| S 共享 (Shared)          | 该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。 | 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 |
| I 无效 (Invalid)         | 该Cache line无效。                                           | 无                                                           |

具体可以参考：[https://www.cnblogs.com/yanlong300/p/8986041.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fyanlong300%2Fp%2F8986041.html)

#### 3. 指令重排序问题

为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执 行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该 结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的 顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不 能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有 类似的指令重排序（Instruction Reorder）优化







## 转载：

[JAVA 并发编程(1)](https://www.jianshu.com/p/2a1d760c2c2a)

   

